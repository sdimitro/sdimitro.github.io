<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Core Dump</title>
    <link>https://sdimitro.github.io/post/index.xml</link>
    <description>Recent content in Posts on Core Dump</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 09 Oct 2016 12:00:00 -0600</lastBuildDate>
    <atom:link href="https://sdimitro.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>OpenZFS Developer Summit 2016</title>
      <link>https://sdimitro.github.io/post/OpenZFS-2016/</link>
      <pubDate>Sun, 09 Oct 2016 12:00:00 -0600</pubDate>
      
      <guid>https://sdimitro.github.io/post/OpenZFS-2016/</guid>
      <description>&lt;p&gt;On September 26th I had the pleasure of going to the OpenZFS Developer
Summit of 2016. You can find more information on the event (slides,
videos, etc..)
&lt;a href=&#34;http://open-zfs.org/wiki/OpenZFS_Developer_Summit_2016&#34;&gt;here&lt;/a&gt;.
The event itself was great. Many great speakers shared their experience
with ZFS and how they use it in their everyday job. Brian Behlendorf, for
example, presented how ZFS is used together with Lustre in supercomputers
in the Livermore National Lab, and the modifications that his team had
to do to ZFS in order for it to serve their use-case. Other presentations
showcased cool features and improvements to ZFS with the goal of
receiving feedback or raising awareness on issues like making the ZFS
test-suite uniform across the different operating systems.&lt;/p&gt;

&lt;p&gt;What I personally found as the most important aspect of the summit was
the fact that many people from the community were gathered together in
one place. You would hear interesting discussions everywhere. From how
individuals first got involved with ZFS to deeply technical discussions
on why ZFS is the way it is. Jeff Bonwick also showed up at the end of
that day but unfortunately I had to go at that time so I only met him
briefly.&lt;/p&gt;

&lt;p&gt;Another cool thing about the summit for a newcomer like me was that I
got to meet people from Delphix and the ZFS community that
I&amp;rsquo;ve been exchanging emails, in person. For example, Richard Elling
was the first person to review my first code submission ever in ZFS
two years ago, when I was still a student.&lt;/p&gt;

&lt;p&gt;Finally, the hackathon in the second day of the summit was an amazing
experience. Individuals from different companies formed teams to work
on new features of ZFS or to refine existing ones. Dan Kimmel and I
quickly hacked together zpool checkpointing with the help of George
Wilson who was basically helping several different groups while also
working on his own project. I had a lot of fun working in zpool
checkpointing with Dan and George, and hopefully we&amp;rsquo;ll put some time
in the future to do a proper rewrite of it and upstream it.&lt;/p&gt;

&lt;p&gt;Overall, I had a great time in the summit and I&amp;rsquo;m already looking
forward to the next one.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://sdimitro.github.io/img/OpenZFS_2016.png&#34; alt=&#34;OpenZFS_2016_logo&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello, Delphix!</title>
      <link>https://sdimitro.github.io/post/hello-delphix/</link>
      <pubDate>Mon, 15 Aug 2016 12:00:00 -0600</pubDate>
      
      <guid>https://sdimitro.github.io/post/hello-delphix/</guid>
      <description>&lt;p&gt;This is not the standard post that comes with a problem,
some motivation, an objective, and a proposed solution.
This post is just an update
and an opportunity for me to share some great news.&lt;/p&gt;

&lt;p&gt;Next week I will be joining the ZFS team of Delphix in
their San Francisco office.  Systems programming/engineering
has always been the most enjoyable area of computers for me
and I believe that this is what I want to do. Having said that,
I believe there is not better place for me to do this than
Delphix. In a way, I feel like a reached a personal Ithaca.&lt;/p&gt;

&lt;p&gt;There are no words to express how excited I am for
this opportunity. I look forward to learn from and work with
Matthew Ahrens, George Wilson, Dan Kimmel, and other heroes
of the ZFS fame that work at Delphix. I look forward to the
challenges ahead. I look forward to examine some ugly core
dumps :-)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The journey of a ZFS read() call in 1 min [Î¼]</title>
      <link>https://sdimitro.github.io/post/zfs-read-dtrace-micro/</link>
      <pubDate>Thu, 11 Aug 2016 12:00:00 -0600</pubDate>
      
      <guid>https://sdimitro.github.io/post/zfs-read-dtrace-micro/</guid>
      <description>

&lt;h3 id=&#34;motivation-objective&#34;&gt;Motivation &amp;amp; Objective&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve been reading up a lot on ZFS recently. As a part
of this study, I&amp;rsquo;m planning to watch a video where Matt
Ahrens goes through the
&lt;a href=&#34;https://www.youtube.com/watch?v=ptY6-K78McY&#34;&gt;read and write codepaths on ZFS&lt;/a&gt;.
Before watching it though, I thought it would be cool if I went
through the code by myself. Then, hopefully, any questions
that I have while reading the code will be addressed in the
video code review.&lt;/p&gt;

&lt;p&gt;As I am becoming more familiar with illumos and its internals
, I decided to use DTrace. My main objective was to create a
map of the codepath so I can have a better sense of direction
while reading the code.&lt;/p&gt;

&lt;h3 id=&#34;the-d-script&#34;&gt;The D script&lt;/h3&gt;

&lt;p&gt;I quickly hacked a script together to achieve my aforementioned
objective. One thing that I had to consider was whether I should
also include the &lt;code&gt;plockstat&lt;/code&gt; provider and include all the locking
points on my map. I decided not to do that. Even though I&amp;rsquo;m
planning to understand the reason behind using the different locks
on the critical points that I will encounter, my objective
is not to read the implementation of these mechanisms. Furthermore,
their output on my map would probably be distracting.&lt;/p&gt;

&lt;p&gt;The easiest way that I could think of issuing a clean read()
system call was by using &lt;code&gt;cat&lt;/code&gt; on a file. Therefore, my DTrace
script tries to detect only the first read() call issued by
a &lt;code&gt;cat&lt;/code&gt; command, so its output is hopefully reproducable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;syscall::read:entry
/execname == &amp;quot;cat&amp;quot;/
{
    self-&amp;gt;t = 1;
}

syscall::read:return
/self-&amp;gt;t/
{
    self-&amp;gt;t = 0;
    exit(0);
}

sdt:::, fbt:::entry, fbt:::return
/self-&amp;gt;t/
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;result&#34;&gt;Result&lt;/h3&gt;

&lt;p&gt;If you are curious what the output looks like check
the Appendix section. illumos kernel devs won&amp;rsquo;t find
anything surprising or out of the ordinary here. The
main point here is that in very little time I was
able to create a map of the path taken by a system
call. I&amp;rsquo;m just barely scratching the surface here
in the number of aids that DTrace can provide me
while I am trying to understand a system that is
being developed for more than a decade. Off to read
some code now!&lt;/p&gt;

&lt;h3 id=&#34;appendix-output&#34;&gt;Appendix: Output&lt;/h3&gt;

&lt;p&gt;The following output was produced in my OmniOS
VM running on vagrant provided by OmniTI. I also
used the &lt;code&gt;-F&lt;/code&gt; option of the dtrace utility for a
better visualization of the path.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CPU FUNCTION                                 
  0  -&amp;gt; read32                                
  0    -&amp;gt; read                                
  0      -&amp;gt; getf                              
  0        -&amp;gt; set_active_fd                   
  0        &amp;lt;- set_active_fd                   
  0        -&amp;gt; set_active_fd                   
  0        &amp;lt;- set_active_fd                   
  0      &amp;lt;- getf                              
  0      -&amp;gt; nbl_need_check                    
  0      &amp;lt;- nbl_need_check                    
  0      -&amp;gt; fop_rwlock                        
  0        -&amp;gt; fs_rwlock                       
  0        &amp;lt;- fs_rwlock                       
  0      &amp;lt;- fop_rwlock                        
  0      -&amp;gt; fop_read                          
  0        -&amp;gt; crgetmapped                     
  0        &amp;lt;- crgetmapped                     
  0        -&amp;gt; zfs_read                        
  0          -&amp;gt; rrm_enter_read                
  0            -&amp;gt; rrw_enter_read              
  0              -&amp;gt; rrw_enter_read_impl       
  0              &amp;lt;- rrw_enter_read_impl       
  0            &amp;lt;- rrw_enter_read              
  0          &amp;lt;- rrm_enter_read                
  0          -&amp;gt; zfs_range_lock                
  0            -&amp;gt; kmem_alloc                  
  0              -&amp;gt; kmem_cache_alloc          
  0              &amp;lt;- kmem_cache_alloc          
  0            &amp;lt;- kmem_alloc                  
  0            -&amp;gt; avl_numnodes                
  0            &amp;lt;- avl_numnodes                
  0            -&amp;gt; avl_add                     
  0              -&amp;gt; avl_find                  
  0              &amp;lt;- avl_find                  
  0              -&amp;gt; avl_insert                
  0              &amp;lt;- avl_insert                
  0            &amp;lt;- avl_add                     
  0          &amp;lt;- zfs_range_lock                
  0          -&amp;gt; vn_has_cached_data            
  0          &amp;lt;- vn_has_cached_data            
  0          -&amp;gt; sa_get_db                     
  0          &amp;lt;- sa_get_db                     
  0          -&amp;gt; dmu_read_uio_dbuf             
  0            -&amp;gt; zrl_add_impl                
  0            &amp;lt;- zrl_add_impl                
  0            -&amp;gt; dmu_read_uio_dnode          
  0              -&amp;gt; dmu_buf_hold_array_by_dnode 
  0                -&amp;gt; kmem_zalloc             
  0                  -&amp;gt; kmem_cache_alloc      
  0                  &amp;lt;- kmem_cache_alloc      
  0                &amp;lt;- kmem_zalloc             
  0                -&amp;gt; zio_root                
  0                  -&amp;gt; zio_null              
  0                    -&amp;gt; zio_create          
  0                      -&amp;gt; kmem_cache_alloc  
  0                      &amp;lt;- kmem_cache_alloc  
  0                      -&amp;gt; mutex_init        
  0                      &amp;lt;- mutex_init        
  0                      -&amp;gt; cv_init           
  0                      &amp;lt;- cv_init           
  0                      -&amp;gt; list_create       
  0                      &amp;lt;- list_create       
  0                      -&amp;gt; list_create       
  0                      &amp;lt;- list_create       
  0                      -&amp;gt; zfs_zone_zio_init 
  0                      &amp;lt;- zfs_zone_zio_init 
  0                    &amp;lt;- zio_create          
  0                  &amp;lt;- zio_null              
  0                &amp;lt;- zio_root                
  0                -&amp;gt; dbuf_whichblock         
  0                &amp;lt;- dbuf_whichblock         
  0                -&amp;gt; dbuf_hold               
  0                  -&amp;gt; dbuf_hold_level       
  0                    -&amp;gt; dbuf_hold_impl      
  0                      -&amp;gt; dbuf_find         
  0                        -&amp;gt; dbuf_hash       
  0                        &amp;lt;- dbuf_hash       
  0                      &amp;lt;- dbuf_find         
  0                      -&amp;gt; arc_buf_add_ref   
  0                        -&amp;gt; buf_hash        
  0                        &amp;lt;- buf_hash        
  0                        -&amp;gt; add_reference   
  0                          -&amp;gt; arc_buf_type  
  0                          &amp;lt;- arc_buf_type  
  0                          -&amp;gt; multilist_remove 
  0                            -&amp;gt; arc_state_multilist_index_func 
  0                              -&amp;gt; buf_hash  
  0                              &amp;lt;- buf_hash  
  0                              -&amp;gt; multilist_get_num_sublists 
  0                              &amp;lt;- multilist_get_num_sublists 
  0                            &amp;lt;- arc_state_multilist_index_func 
  0                           | multilist_remove:multilist-remove 
  0                           | multilist_remove:multilist-remove 
  0                            -&amp;gt; mutex_owned 
  0                            &amp;lt;- mutex_owned 
  0                            -&amp;gt; multilist_sublist_remove 
  0                              -&amp;gt; list_remove 
  0                              &amp;lt;- list_remove 
  0                            &amp;lt;- multilist_sublist_remove 
  0                          &amp;lt;- multilist_remove 
  0                        &amp;lt;- add_reference   
  0                       | arc_buf_add_ref:arc-hit 
  0                       | arc_buf_add_ref:arc-hit 
  0                        -&amp;gt; arc_access      
  0                          -&amp;gt; ddi_get_lbolt 
  0                            -&amp;gt; lbolt_event_driven 
  0                              -&amp;gt; gethrtime 
  0                                -&amp;gt; tsc_gethrtime 
  0                                &amp;lt;- tsc_gethrtime 
  0                              &amp;lt;- gethrtime 
  0                            &amp;lt;- lbolt_event_driven 
  0                          &amp;lt;- ddi_get_lbolt 
  0                        &amp;lt;- arc_access      
  0                      &amp;lt;- arc_buf_add_ref   
  0                    &amp;lt;- dbuf_hold_impl      
  0                  &amp;lt;- dbuf_hold_level       
  0                &amp;lt;- dbuf_hold               
  0                -&amp;gt; dbuf_read               
  0                  -&amp;gt; zrl_add_impl          
  0                  &amp;lt;- zrl_add_impl          
  0                  -&amp;gt; zrl_remove            
  0                  &amp;lt;- zrl_remove            
  0                &amp;lt;- dbuf_read               
  0                -&amp;gt; dmu_zfetch              
  0                &amp;lt;- dmu_zfetch              
  0                -&amp;gt; zio_wait                
  0                  -&amp;gt; zio_execute           
  0                    -&amp;gt; zio_ready           
  0                      -&amp;gt; zio_wait_for_children 
  0                      &amp;lt;- zio_wait_for_children 
  0                      -&amp;gt; zio_wait_for_children 
  0                      &amp;lt;- zio_wait_for_children 
  0                      -&amp;gt; zio_walk_parents  
  0                        -&amp;gt; list_head       
  0                        &amp;lt;- list_head       
  0                      &amp;lt;- zio_walk_parents  
  0                    &amp;lt;- zio_ready           
  0                    -&amp;gt; zio_done            
  0                      -&amp;gt; zio_wait_for_children 
  0                      &amp;lt;- zio_wait_for_children 
  0                      -&amp;gt; zio_wait_for_children 
  0                      &amp;lt;- zio_wait_for_children 
  0                      -&amp;gt; zio_wait_for_children 
  0                      &amp;lt;- zio_wait_for_children 
  0                      -&amp;gt; zio_wait_for_children 
  0                      &amp;lt;- zio_wait_for_children 
  0                      -&amp;gt; zio_inherit_child_errors 
  0                      &amp;lt;- zio_inherit_child_errors 
  0                      -&amp;gt; zio_inherit_child_errors 
  0                      &amp;lt;- zio_inherit_child_errors 
  0                      -&amp;gt; zio_inherit_child_errors 
  0                      &amp;lt;- zio_inherit_child_errors 
  0                      -&amp;gt; zio_pop_transforms 
  0                      &amp;lt;- zio_pop_transforms 
  0                      -&amp;gt; vdev_stat_update  
  0                      &amp;lt;- vdev_stat_update  
  0                      -&amp;gt; zio_inherit_child_errors 
  0                      &amp;lt;- zio_inherit_child_errors 
  0                      -&amp;gt; zio_gang_tree_free 
  0                      &amp;lt;- zio_gang_tree_free 
  0                      -&amp;gt; zio_walk_parents  
  0                        -&amp;gt; list_head       
  0                        &amp;lt;- list_head       
  0                      &amp;lt;- zio_walk_parents  
  0                      -&amp;gt; cv_broadcast      
  0                      &amp;lt;- cv_broadcast      
  0                    &amp;lt;- zio_done            
  0                  &amp;lt;- zio_execute           
  0                  -&amp;gt; zio_destroy           
  0                    -&amp;gt; list_destroy        
  0                    &amp;lt;- list_destroy        
  0                    -&amp;gt; list_destroy        
  0                    &amp;lt;- list_destroy        
  0                    -&amp;gt; mutex_destroy       
  0                    &amp;lt;- mutex_destroy       
  0                    -&amp;gt; cv_destroy          
  0                    &amp;lt;- cv_destroy          
  0                    -&amp;gt; kmem_cache_free     
  0                    &amp;lt;- kmem_cache_free     
  0                  &amp;lt;- zio_destroy           
  0                &amp;lt;- zio_wait                
  0              &amp;lt;- dmu_buf_hold_array_by_dnode 
  0              -&amp;gt; uiomove                   
  0                -&amp;gt; xcopyout_nta            
  0                &amp;lt;- kcopy                   
  0              &amp;lt;- uiomove                   
  0              -&amp;gt; dmu_buf_rele_array        
  0                -&amp;gt; dbuf_rele               
  0                  -&amp;gt; dbuf_rele_and_unlock  
  0                    -&amp;gt; arc_buf_freeze      
  0                    &amp;lt;- arc_buf_freeze      
  0                    -&amp;gt; arc_released        
  0                    &amp;lt;- arc_released        
  0                    -&amp;gt; arc_buf_remove_ref  
  0                      -&amp;gt; buf_hash          
  0                      &amp;lt;- buf_hash          
  0                      -&amp;gt; remove_reference  
  0                        -&amp;gt; arc_buf_type    
  0                        &amp;lt;- arc_buf_type    
  0                        -&amp;gt; multilist_insert 
  0                          -&amp;gt; arc_state_multilist_index_func 
  0                            -&amp;gt; buf_hash    
  0                            &amp;lt;- buf_hash    
  0                            -&amp;gt; multilist_get_num_sublists 
  0                            &amp;lt;- multilist_get_num_sublists 
  0                          &amp;lt;- arc_state_multilist_index_func 
  0                         | multilist_insert:multilist-insert 
  0                         | multilist_insert:multilist-insert 
  0                          -&amp;gt; mutex_owned   
  0                          &amp;lt;- mutex_owned   
  0                          -&amp;gt; multilist_sublist_insert_head 
  0                            -&amp;gt; list_insert_head 
  0                            &amp;lt;- list_insert_head 
  0                          &amp;lt;- multilist_sublist_insert_head 
  0                        &amp;lt;- multilist_insert 
  0                      &amp;lt;- remove_reference  
  0                    &amp;lt;- arc_buf_remove_ref  
  0                    -&amp;gt; arc_buf_eviction_needed 
  0                    &amp;lt;- arc_buf_eviction_needed 
  0                  &amp;lt;- dbuf_rele_and_unlock  
  0                &amp;lt;- dbuf_rele               
  0                -&amp;gt; kmem_free               
  0                  -&amp;gt; kmem_cache_free       
  0                  &amp;lt;- kmem_cache_free       
  0                &amp;lt;- kmem_free               
  0              &amp;lt;- dmu_buf_rele_array        
  0            &amp;lt;- dmu_read_uio_dnode          
  0            -&amp;gt; zrl_remove                  
  0            &amp;lt;- zrl_remove                  
  0          &amp;lt;- dmu_read_uio_dbuf             
  0          -&amp;gt; zfs_range_unlock              
  0            -&amp;gt; zfs_range_unlock_reader     
  0              -&amp;gt; avl_remove                
  0              &amp;lt;- avl_remove                
  0              -&amp;gt; kmem_free                 
  0                -&amp;gt; kmem_cache_free         
  0                &amp;lt;- kmem_cache_free         
  0              &amp;lt;- kmem_free                 
  0            &amp;lt;- zfs_range_unlock_reader     
  0          &amp;lt;- zfs_range_unlock              
  0          -&amp;gt; zfs_tstamp_update_setup       
  0            -&amp;gt; gethrestime                 
  0              -&amp;gt; pc_gethrestime            
  0                -&amp;gt; gethrtime               
  0                  -&amp;gt; tsc_gethrtime         
  0                  &amp;lt;- tsc_gethrtime         
  0                &amp;lt;- gethrtime               
  0              &amp;lt;- pc_gethrestime            
  0            &amp;lt;- gethrestime                 
  0          &amp;lt;- zfs_tstamp_update_setup       
  0          -&amp;gt; rrm_exit                      
  0            -&amp;gt; rrw_exit                    
  0              -&amp;gt; cv_broadcast              
  0              &amp;lt;- cv_broadcast              
  0            &amp;lt;- rrw_exit                    
  0          &amp;lt;- rrm_exit                      
  0        &amp;lt;- zfs_read                        
  0      &amp;lt;- fop_read                          
  0      -&amp;gt; fop_rwunlock                      
  0        -&amp;gt; fs_rwunlock                     
  0        &amp;lt;- fs_rwunlock                     
  0      &amp;lt;- fop_rwunlock                      
  0      -&amp;gt; releasef                          
  0        -&amp;gt; clear_active_fd                 
  0        &amp;lt;- clear_active_fd                 
  0        -&amp;gt; cv_broadcast                    
  0        &amp;lt;- cv_broadcast                    
  0      &amp;lt;- releasef                          
  0    &amp;lt;- read
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>How does my computer know about time zones?</title>
      <link>https://sdimitro.github.io/post/keeping-track-time/</link>
      <pubDate>Tue, 07 Jun 2016 12:00:00 -0600</pubDate>
      
      <guid>https://sdimitro.github.io/post/keeping-track-time/</guid>
      <description>

&lt;p&gt;&amp;ldquo;&lt;em&gt;Even simple-looking things can sometimes have a
surprising twist in software. And everyone who thinks
that programming dates is easy to get right the first
time probably hasn&amp;rsquo;t done much of it.&lt;/em&gt;&amp;rdquo; &lt;br&gt;
&amp;ndash; Peter van der Linden (Expert C Programming)&lt;/p&gt;

&lt;h3 id=&#34;main-problem-and-motivation&#34;&gt;Main Problem and Motivation&lt;/h3&gt;

&lt;p&gt;Recently, a colleague of mine introduced me to &lt;a href=&#34;http://www.worldtimebuddy.com/&#34;&gt;World Time
Buddy&lt;/a&gt;, a convenient world
clock and time zone converter used to schedule online
meetings. I liked the application and I decided that
I would like to develop a clone of it that would work
locally with no internet connection and output the specified
time zone data as plain text in the command line.&lt;/p&gt;

&lt;p&gt;So I made a quick utility that does this exact thing
(or at least I have some confidence that it does). The
problem was that I did not know how
does my computer have all this information about time
zones used by different countries. My mind was boggling.
I was trying to think of all the different edge cases that
can show up on my simple world clock and at the same time
I was wondering if my computer can handle them all by
default.&lt;/p&gt;

&lt;h3 id=&#34;what-can-go-wrong&#34;&gt;What Can Go Wrong&lt;/h3&gt;

&lt;p&gt;There are many timing problems that can show up within
a single computer system (e.g., the RTC and the system
clock drifting apart from each other). Fortunately,
there exist mechanisms in the OS and hardware that
take care of most of them for us. The main thing I was
unsure of was the following: how does one go about making
an application that maps all (or at least most) locations
to a time zone and a Daylight Saving Time (DST) schedule,
if applicable, at any moment.&lt;/p&gt;

&lt;p&gt;As an example, let&amp;rsquo;s consider a clock that shows the
current time in Chicago(US) and Athens(Greece). Athens
is 8 hours ahead of Chicago normally and both cities
observe DST. The issue is that their DST schedules
are not synchronized. At the year of this writing, Chicago
turned their clocks 1 hour forward at March 13th  and it will
turn them back 1 hour at November 6th. At the same time,
Athens turned their clocks forward at March 27th and will
turn them back at October 30th. This means that between
March 13th and March 27th the time difference was 7
hours instead of 8 and the same will happen again between
October 30th and November 6th.&lt;/p&gt;

&lt;p&gt;After thinking of the above example, I wanted to search
for other edge cases and get a better understanding of
the challenges of building a world clock. It
turned out that these edge cases are so many I can&amp;rsquo;t
even list them all. For example, several areas recognize
partial offsets within a time zone (e.g., 30 and 15-minute
offsets). Another example is that there exist places
that are on the same time for half a year and an hour
apart for the other half because even though they are
all in the same time zone, some of them do not adhere
to DST. As one reads more examples that differ in
nature like the previous two, it becomes obvious
that these &amp;ldquo;irregularities&amp;rdquo; are not edge cases but the rule.&lt;/p&gt;

&lt;p&gt;So the next question is the following: Even if we
were to store all these information somewhere, how
often would we have to change it? In other words,
how often do the different areas around the globe
decide to change their time policy?&lt;/p&gt;

&lt;p&gt;It turns out to be more often than most people think.
To give an example, last year (2015) around 15 different
places (countries or areas within countries) changed
something about their time policy, either temporarily
for that year or &amp;ldquo;more permanently&amp;rdquo; for the years to
come. Chile abolished DST while Turkey delayed its DST
end time by two weeks and North Korea introduced its
own time zone.&lt;/p&gt;

&lt;h3 id=&#34;how-do-we-manage&#34;&gt;How Do We Manage&lt;/h3&gt;

&lt;p&gt;Most operating systems today keep the system time as
UTC and instead of having a single time zone set for
the whole computer they allow the user to configure
the time as they wish. In Unix-like systems, a user
generally sets the timezone during the installation
of the OS and can later vary the time zone of a
process using the TZ environment variable. This means
that the OS uses some kind of local database for
countries and time zones. On my Linux machine this
database exists in &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt; and gets
updated during my system updates by my distributions&amp;rsquo;s
updating mechanism/application.&lt;/p&gt;

&lt;p&gt;This local database with all the timezone information
generally comes from the
&lt;a href=&#34;https://www.iana.org/time-zones&#34;&gt;IANA time zone database&lt;/a&gt;
(sometimes called OlsonDB) which is an ongoing
collaborative compilation of information about all
the timezone and DST cases intended to be used with
computer programs and operating systems. This database
does not only contain the current time rules in the
different areas, but also the history of time changes
from decades ago. This can be useful for applications
that focus on exact duration of events rather than
specific points in time.&lt;/p&gt;

&lt;p&gt;If your OS does not ship with any of those
databases and has some other mechanism you can still
develop applications that use them. Many programming
languages in their attempt to be more portable,
generally ship with a copy of IANA or similar.&lt;/p&gt;

&lt;h3 id=&#34;final-note&#34;&gt;Final Note&lt;/h3&gt;

&lt;p&gt;You can read more about IANA and the data of its data on its
&lt;a href=&#34;https://en.wikipedia.org/wiki/Tz_database&#34;&gt;wiki page&lt;/a&gt;
or learn more about the procedures of adding and changing
time rules in it by reading the archives of its
&lt;a href=&#34;http://mm.icann.org/pipermail/tz/&#34;&gt;submissions mailing list&lt;/a&gt;.
&lt;a href=&#34;http://www.timeanddate.com/&#34;&gt;TimeAndDate&lt;/a&gt; is also a
useful resource to keep track of the changes in time
in the different areas.&lt;/p&gt;

&lt;p&gt;The utility mentioned in the introduction that I&amp;rsquo;ve
been trying to write is incredibly simple considering
its requirements and therefore it suffices to
just plug it into IANA. There exist more complicated
groups of programs out there (e.g., vehicle or package
tracking) whose requirements may not be that simple.
In that case, the programmers should be more aware of
the pitfalls of keeping track of time in their software.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Notes on Testing: Legacy code in illumos</title>
      <link>https://sdimitro.github.io/post/nuking-legacy-code/</link>
      <pubDate>Mon, 22 Dec 2014 12:00:00 -0600</pubDate>
      
      <guid>https://sdimitro.github.io/post/nuking-legacy-code/</guid>
      <description>&lt;p&gt;Last Friday, Robert Mustacchi shared
&lt;a href=&#34;http://illumos.org/books/dev/&#34;&gt;a great guide&lt;/a&gt; that new developers
can reference when working with the illumos build system. As I was
reading it, I came across the section on
&lt;a href=&#34;http://illumos.org/books/dev/workflow.html#testing&#34;&gt;testing changes&lt;/a&gt;
in the basic
workflow chapter. In that section Mustacchi gave some general guidelines
on how a developer should decide the way in which their changes should be
tested.&lt;/p&gt;

&lt;p&gt;Recently on illumos-core, I was working on an
&lt;a href=&#34;https://github.com/gdamore/illumos-core/issues/10&#34;&gt;issue&lt;/a&gt;
that had the goal of
removing some legacy code and required me to delete content from many files
(around 293). After I made my edits and did a full nightly build, no errors
showed up in my logs and I was able to boot into my new system.
Garrett D&amp;rsquo;Amore reviewed my code to make sure that nothing suspicious was
going on.&lt;/p&gt;

&lt;p&gt;The problem was that many of the files that I had changed were drivers/systems
that my system didn&amp;rsquo;t even use (random device drivers or SPARC-specific files).
Since I am fairly new to illumos and kernel development in general, I had no
idea how to test these specific changes. Luckily, D&amp;rsquo;Amore pointed me to the
&lt;a href=&#34;http://illumos.org/man/1onbld/wsdiff&#34;&gt;wsdiff(1)&lt;/a&gt; utility.&lt;/p&gt;

&lt;p&gt;As you can see from the man page, if you keep your proto area before applying
your changes, you can use it with wsdiff to find differences in the binaries
between &amp;ldquo;before&amp;rdquo; and &amp;ldquo;after&amp;rdquo; your changes. One thing to remember is that DEBUG
builds tend to carry debug macros which emit line numbers (e.g &lt;code&gt;__LINE__&lt;/code&gt; macro)
so if you run wsdiff between two DEBUG builds to test your changes, be sure that
some, if not all, differences will come from there. (Check option -d of wsdiff
for other relevant info)&lt;/p&gt;

&lt;p&gt;Taking the issue that I mentioned above as an example, running plain wsdiff
after my changes, a report with a huge amount of differences was generated,
due to line numbers. Thus, I had to do two full non-DEBUG builds to make sure
that my binaries stayed the same after my changes. Apparently it is also
possible to invoke wsdiff through &lt;a href=&#34;http://illumos.org/man/1onbld/nightly&#34;&gt;nightly(1)&lt;/a&gt;, looking at Example 4 from
the wsdiff man page.&lt;/p&gt;

&lt;p&gt;Besides my case-study of removing legacy code though, I believe that wsdiff
has its place in testing for other situations as well. Examples can be changes
that touch a lot of files or have to do with libraries. Basically, any change
that risks changing binaries that you are not supposed to, by mistake.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;: A big thanks to Nick Zivkovic for pointing out mistakes in the initial
version of this post.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EDIT 2&lt;/strong&gt;: I suggested adding a section about this to the original guide.
The above information is now
&lt;a href=&#34;https://github.com/illumos/dev-guide/commit/3fcf78337e4177a811013a4845166b58f76d2038&#34;&gt;part of the dev-guide&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EDIT 3&lt;/strong&gt;: The original title on my old Wordpress website was
&amp;ldquo;Notes on Testing: Nuking Legacy code at illumos-core&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Scripting GDB</title>
      <link>https://sdimitro.github.io/post/scripting-gdb/</link>
      <pubDate>Sat, 01 Feb 2014 12:00:00 -0600</pubDate>
      
      <guid>https://sdimitro.github.io/post/scripting-gdb/</guid>
      <description>

&lt;h3 id=&#34;motivation&#34;&gt;Motivation&lt;/h3&gt;

&lt;p&gt;Two semesters ago, I was introduced to gdb in my systems
programming course. Since this was the first time that I
used an actual debugger, I was really impressed by the
things it could do. I wanted to see what gdb was capable
of, so I tried every single command on simple programs.
Unfortunately, by the time I actually needed gdb in my
class projects I forgot most of them.&lt;/p&gt;

&lt;p&gt;To be honest, I was just using gdb whenever I got
segmentation faults from my programs. I would quickly run
to the point where the program had the segmentation fault
and print a bunch of variables to see what was wrong with
it. Sometimes, I&amp;rsquo;d also do a backtrace. This is probably
more than enough for small and simple programs but when
complexity grows it barely helps debugging. On many
occasions, the bug originates in a point in the code that
is distant from the point in the program where the
existence of the bug became apparent. In these cases, just
skimming to the end where the error shows up, doesn&amp;rsquo;t
really help.&lt;/p&gt;

&lt;p&gt;Being a tutor for CS classes in my school, I had a lot of
students that had buggy programs which misbehaved this way.
Since their programs had a large number of lines for course
projects, I decided to encourage them to use gdb more often
and learn more commands. Although that helped 30% of the
students, the majority of them still had problems. They
didn&amp;rsquo;t want to use gdb because it was really tedious and
repetitive for them.&lt;/p&gt;

&lt;p&gt;They were right! Most of their bugs would show up randomly
in a function after the 20th time that function was executed
and still they weren&amp;rsquo;t able to tell if the bug started before
that function was called. Trying to figure out the root cause
of the problem by running gdb in interactive mode was a pain.
They would prefer looking at their source again and again to
figure out the problem. Some of them would even rewrite their
code using different (and usually more complex) program logic,
hoping that the bug would go away.&lt;/p&gt;

&lt;p&gt;I decided to have a look at the scripting capabilities of gdb
and maybe try to help the students efficiently. I did find
some useful information actually and managed to help a lot of
students by showing them how to run gdb scripts. This whole
experience motivated me to write this small tutorial on basic
gdb scripting. Don&amp;rsquo;t get me wrong, I secretly like the challenge
of debugging in programming. Also, scripting gdb is really easy
and it doesn&amp;rsquo;t take that much time to teach. On the other hand,
I would prefer spending my time as a tutor actually teaching
people new material and not have my brain fried after trying
to understand/debug some person&amp;rsquo;s code for hours.&lt;/p&gt;

&lt;h3 id=&#34;tutorial&#34;&gt;Tutorial&lt;/h3&gt;

&lt;p&gt;By default during startup, gdb executes the file &lt;code&gt;.gdbinit&lt;/code&gt;.
This is where you write your gdb code. In case you want to
have many scripts that test different things, you can tell
gdb to look at other scripts besides the default one by adding
the &lt;code&gt;--command=&amp;lt;filename&amp;gt;&lt;/code&gt; argument when running gdb.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s say that you want a backtrace every time a specific
function is called. This is extremely useful when debugging
recursive functions!. You would write the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set pagination off
set logging file gdb.output
set logging on

# This line is a comment
break function_name
    command 1
    backtrace
    continue
end

run

set logging off
quit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what happens here? I turn pagination off so I don&amp;rsquo;t have to
press Enter for every page of gdb output. I declare that I want
to log all the output of gdb in a file called &lt;code&gt;gdb.output&lt;/code&gt;. Then
I start logging gdb&amp;rsquo;s output and I set a breakpoint in my function.
I use &lt;code&gt;command &amp;lt;breakpoint number&amp;gt;&lt;/code&gt; (this case 1, because
&lt;code&gt;function_name&lt;/code&gt; is our first break point) to provide the commands
that I want to be ran whenever gdb hits that breakpoint. As you
can see I just print a backtrace and then continue until gdb hits
another breakpoint. Now that everything is set, I run the program
and when that finishes, I stop logging the output and quit gdb.
That&amp;rsquo;s it! Now I can run gdb once and take a look at its output by
opening &lt;code&gt;gdb.output&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;By the way, if your program takes certain arguments you can pass
them as arguments in gdb. For example, run
&lt;code&gt;gdb --args ./a.out arg1 arg2 ...etc&lt;/code&gt;. Another way is finding the
line that you execute &lt;code&gt;run&lt;/code&gt; on your script and change it to
&lt;code&gt;run arg1 arg2 ...etc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Most of the time though, you don&amp;rsquo;t really need all this output.
What if you needed to break in a function when a certain parameter
of that function is passed a specific value? What if you needed to
break to a certain line of code the 3rd time it is executed? You
can do all these as I am going to show in the example below. So
let&amp;rsquo;s say, I want to break in function1 when one of its arguments,
&lt;code&gt;param1&lt;/code&gt;, is 32. I also want to break in line 142 of &lt;code&gt;file.c&lt;/code&gt; when the
variable &lt;code&gt;x&lt;/code&gt; (which is in the same scope with the statement in line
142) is bigger than 4. Finally I want to set a breakpoint in
&lt;code&gt;function2&lt;/code&gt; and I want gdb to break the first 3 times this function
is executed.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set pagination off
set logging file gdb.output
set logging on

set $var = 0 # yes, you can declare variables ...

break function1 if param1 == 32
    command 1
    print param2
    print param3-&amp;gt;member1
    continue
end

break file.c:142 if x &amp;gt; 4
    command 2
    print y
    call checker_function
    continue
end

break function2 if $var++ &amp;lt; 3
    command 3
    print $var
    backtrace full
    continue
end

run

set logging off
quit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it! This is the end of this tutorial. In my
humble opinion the above are more or less enough for
programs of little to medium complexity. You can go
ahead and learn more advanced features of gdb or research
dynamic tracing that has been slowly coming to Linux
(most UNIX platforms have that already). Even if you don&amp;rsquo;t
program actively on your own for the time being, knowing
how to run and script a debugger helps a lot in the
improvement of open source programs. For example, if your
favourite program suddenly crashes and you can send a
crash/bug report, attaching a simple backtrace and other
gdb output that displays extra information will save a lot
of time for the developers that will try to fix your problem.&lt;/p&gt;

&lt;h3 id=&#34;some-final-notes&#34;&gt;Some Final Notes&lt;/h3&gt;

&lt;p&gt;Before I finish this post, I just want to give a piece of
advice when using gdb. If your program crashes for whatever
reason and you have a rough idea where that happens, just
look at the relevant part of code for a while to see if it
makes sense. We often type things by mistake when we are
absent-minded that compile and give off-by-one and other
type of errors. If that part of code is complex just go
through it using gdb in interactive mode, don&amp;rsquo;t start
writing/editing scripts right away that target a bug you
just found. You may actually spend more time writing a
script to find a bug than actually stepping through your
program in your head or using a debugger.&lt;/p&gt;

&lt;p&gt;I would also like to encourage writing more checker functions
in your source code that check conditions (or print out debug
info on the program output during development) than huge gdb
scripts with complicated logic. Checker function in your source
can be called directly from your program AND from your gdb
scripts too (see 2nd example script). Besides, checker function
provide more flexible access to the internals of your program
and they are written in the same language as the rest of your
program.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;: A big thanks to Nick Zivkovic for pointing out some
mistakes in the initial version of this post.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>