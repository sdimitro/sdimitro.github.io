<!DOCTYPE html>
<html lang="en-us">
	<meta charset="UTF-8">
	<title>Libdmem | Core Dump</title>
	<link href="https://fonts.googleapis.com/css?family=Libre+Baskerville" rel="stylesheet"> 
	<link href="https://fonts.googleapis.com/css?family=PT+Sans" rel="stylesheet"> 
	<link rel="stylesheet" href="https://sdimitro.github.io/css/style.css">

<div class="header">
	<h3><a href="https://sdimitro.github.io">Core Dump</a></h3>
</div>

<div class="main">
	<div class="article">
		<h1>Libdmem
			<div class="normal">
				<div class="when"> Posted on January 10, 2020.</div>
			</div>
		</h1>
   <div class="content">
     <p>At Delphix we deal with userland core dumps as much as kernel crash dumps. The
majority of the time these userland dumps are generated by memory-related
issues - a Java process hitting an OutOfMemory error for example. In such case,
we generally use <a href="https://visualvm.github.io/">VisualVM</a> or
<a href="https://www.eclipse.org/mat/">EclipseMAT</a> to analyze the memory consumption by
class, object, etc.. then look at the number of threads within that process,
and then if that’s not enough we look into the native heap.  My former
colleague, Dan Kimmel, wrote <a href="https://systemsbuffet.wordpress.com/2015/04/10/defanging-the-outofmemoryerror/">an excellent
post</a>
for these memory-related issues and how we deal with them in illumos/DelphixOS.
Most of the insights in his post carry over to Linux as-is, except the analysis
of the native heap.</p>

<p><code>libumem</code> (a library that can be though of as the kernel slab allocator but for
the userland in illumos) was build with debuggability in mind and it can
<a href="https://illumos.org/man/3MALLOC/umem_debug">optionally keep track of extra
metadata</a> in memory so that <code>mdb</code>
(the illumos debugger) can <a href="https://blogs.oracle.com/jwadams/debugging-with-libumem-and-mdb">print useful
information</a>
when debugging memory problems such as <a href="http://technopark02.blogspot.com/2016/08/solaris-memory-leak-checking-with.html">memory
leaks</a>
and memory exhaustion. At Delphix, we’ll soon be in the process of figuring out
the procedures/tools that we’ll be using to deal with such issues in Linux
which I believe will look something like this:</p>

<ol>
<li><p>Look what the existing memory allocators, like glibc and jemalloc, offer in
terms of debugging infrastructure.</p></li>

<li><p>Consider how appropriate <a href="https://github.com/gburd/libumem">existing ports</a>
of the illumos libumem in Linux or Bonwick’s newer
<a href="https://github.com/thecodeteam/dssd/tree/master/lib/libvmem">libvmem</a> from
DSSD are for our use-case.</p></li>

<li><p>Once these have been examined, pick the one that gives the best trade-off in
terms of performance, debuggability, community involvement, and maintenance
burden. Then write SDB commands for it and potentially attempt to contribute
any missing functionality upstream.</p></li>
</ol>

<p>While the above is most probably what will end up happening there is always the
option of creating a solution from scratch — an option that I believe should
always be considered. To be pragmatic, I don’t think that writing a memory
allocator from scratch just for our use-case is worthwhile given our current
resources and constraints regardless of how fun it may sound at first. On the
other hand though, attempting to implement just the debugging facilities that
we are missing in an allocator-agnostic way may not be as far fetched.</p>

<p>With the above idea in mind, I spent a few hours between Christmas Eve and New
Years to write <a href="https://github.com/sdimitro/libdmem">libdmem</a>. The library is
in experimental stages (and probably will remain like that) and it provides the
bare-minimal in under 500 lines of actual C code. The way that it works is that
it interposes its own <code>malloc()</code> and friends functions on top of their actual
implementations (tested on top of glibc and jemalloc so far) and for each
allocation it asks for a few more bytes (~112 bytes currently) to store its
metadata. The metadata currently consist of a pointer to the thread that made
the allocation, 10 pointers that record the program counters at the top of the
stack, and 2 pointers that allow the segment to be added in a doubly-linked
list.</p>

<p>I’ve successfully ran standard Linux utilities (<code>ls</code>, <code>cat</code>, etc..) and few
more complex programs like <code>vim</code>, <code>wget</code>, and <code>python3</code> with <code>libdmem</code>
interposed on top of glibc and jemalloc. I’ve also generated core dumps from
these runs and ensured that I could walk the linked lists and print the stacks
successfully. For a quick demonstration on the <code>driver</code> program below:</p>

<pre><code>int
main(void)
{
    char *p = malloc(512);
    for (int i = 0; i &lt; 510; i++)
        p[i] = 'A' + (i % 26);
    p[511] = '\0';
    printf(&quot;%s\n&quot;, p);
    free(p);
    /* leak! */
    p = malloc(2048);
    for (int i = 0; i &lt; 2046; i++)
        p[i] = 'A' + (i % 26);
    p[2047] = '\0';
    printf(&quot;%s\n&quot;, p);
    return 0;
}
</code></pre>

<p>We run the program and interpose <code>libdmem</code> on it like this:</p>

<pre><code>$ DMEM_OPTS=trace-stderr,log-allocs,abort-shutdown LD_PRELOAD=./libdmem.so ./driver
</code></pre>

<p>Because we’ve enabled <code>trace-stderr</code> we print all the calls to <code>malloc()</code> and
friends as they happen:</p>

<pre><code>malloc(512) = 0x557abe66f2d0  // &lt;-- first malloc() call
malloc(1024) = 0x557abe66f550 // &lt;-- printf() allocation
ABCDEFGH...&lt;cropped&gt;...
free(0x557abe66f2d0)
malloc(2048) = 0x557abe66f9d0 // &lt;-- second malloc() call
ABCDEFGH...&lt;cropped&gt;...
</code></pre>

<p>Generating a core-dump at the end of the program run we use a rudimentary <a href="https://github.com/sdimitro/libdmem/blob/master/libdmem-gdb.py#L51">gdb
command</a>
that I wrote in Python that goes through all the leaks and shows the stack
trace of their allocation:</p>

<pre><code>$ gdb driver /var/crash/core.driver.29714.1577846611
(gdb) source ./libdmem-gdb.py
(gdb) show_alloc_stacks
0x557abe66f960 allocated from 0x7f7a52ec8740 at:
        malloc+287
        main+1656
        __libc_start_main+231
        _start+42
0x557abe66f4e0 allocated from 0x7f7a52ec8740 at:
        malloc+287
        __GI__IO_file_doallocate+140
        __GI__IO_doallocbuf+121
        _IO_new_file_overflow+408
        _IO_new_file_xsputn+189
        _IO_puts+207
        main+1638
        __libc_start_main+231
        _start+42
</code></pre>

<p>The first stack trace is from the leak in our C program (the 2048-byte
allocation). The second stack trace is not an actual leak. The allocation
happened as part of the first <code>printf()</code> call and is actually freed after our
program exits as glibc gets unloaded. Unfortunately, I wasn’t able to get a
core dump exactly at that point, so the allocation shows up in the above
report.</p>

<p>I’ve learned a lot writing this library and many of those lessons I’ve tried
documenting in the comments of the code (e.g. <a href="https://github.com/sdimitro/libdmem/blob/master/dmem.c#L437">interposing malloc()
correctly</a> while
creating a reference to the underlying malloc() implementation is not as easy
as it sounds and <a href="http://man7.org/linux/man-pages/man8/ld.so.8.html">LD_DEBUG</a>
is invaluable for debugging issues in dynamic loading of shared objects). If I
ever get the time I’d be interested to try out <code>libdmem</code> on one of our
performance machines at Delphix to see what’s the slowdown and memory overhead
that it induces for our workloads.</p>

   </div>
	</div>
</div>
<div id="disqus_thread"></div>
<script>


   var disqus_config = function () {
	   this.page.url = "https://sdimitro.github.io""Libdmem";
	   this.page.identifier = "Libdmem";
   };
(function() { 
	if (window.location.hostname == "localhost")
		return;
	var d = document, s = d.createElement('script');
	s.src = '//sdimitro-github-com.disqus.com/embed.js';
	s.setAttribute('data-timestamp', +new Date());
	(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-78963448-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


